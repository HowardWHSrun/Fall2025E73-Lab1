<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quantum Mechanical Simulations</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #ffffff;
            min-height: 100vh;
        }
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #2d3748;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        .subtitle {
            text-align: center;
            color: #718096;
            margin-bottom: 30px;
            font-size: 1.05em;
        }
        .problem {
            margin-bottom: 50px;
            padding: 25px;
            background: #ffffff;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 6px 18px rgba(0,0,0,0.06);
        }
        h2 {
            color: #4a5568;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        canvas {
            border: 1px solid #d1d5db;
            border-radius: 10px;
            display: block;
            margin: 20px auto;
            background: #ffffff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            width: 100%;
            height: auto;
            aspect-ratio: 16/7;
        }
        .plot {
            border: 1px solid #d1d5db;
            border-radius: 10px;
            display: block;
            margin: 20px auto;
            background: #ffffff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            width: 100%;
            height: 560px;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px 0 5px;
            flex-wrap: wrap;
        }
        .controls label {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255,255,255,0.8);
            padding: 6px 10px;
            border-radius: 8px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.08);
        }
        .slider-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 16px;
            margin: 12px 0 8px;
        }
        .slider-container {
            margin: 10px 0;
            padding: 12px 12px 8px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #4a5568;
        }
        input[type="range"] {
            width: 100%;
            margin: 6px 0 0;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 5px;
            background: #e5e7eb;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        button {
            padding: 10px 18px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.25);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        button:active {
            transform: translateY(0);
        }
        .info {
            background: #fffbea;
            padding: 12px;
            border-radius: 10px;
            margin: 12px 0;
            font-size: 14px;
            color: #2d3748;
            border: 1px solid #fde68a;
        }
        .equation {
            background: white;
            padding: 10px;
            border-left: 4px solid #2563eb;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            border-radius: 5px;
        }
        .small {
            font-size: 12px;
            color: #4a5568;
        }
    </style>
 </head>
<body>
    <div class="container">
        <h1>Quantum Mechanical Simulations</h1>
        <p class="subtitle">Interactive probability densities and potentials (1D time‑independent Schrödinger)</p>

        <!-- Infinite Square Well -->
        <div class="problem">
            <h2>1. Infinite Square Well</h2>
            <div class="equation">V(x) = 0 on (−L/2, L/2); ψ(±L/2)=0</div>
            <div class="info">Computes lowest eigenstates inside an infinite well using finite differences. Adjust the well width and see the spectrum change.</div>
            <div class="slider-grid">
                <div class="slider-container">
                    <label>Well width L (nm): <span id="iw_L_val">1.0</span></label>
                    <input id="iw_L" type="range" min="0.5" max="5" step="0.1" value="1.0" />
                </div>
                <div class="slider-container">
                    <label>Grid points N: <span id="iw_N_val">200</span></label>
                    <input id="iw_N" type="range" min="80" max="320" step="10" value="200" />
                </div>
                <div class="slider-container">
                    <label>States to show: <span id="iw_K_val">4</span></label>
                    <input id="iw_K" type="range" min="1" max="8" step="1" value="4" />
                </div>
            </div>
            <div class="controls">
                <button id="iw_run">Compute</button>
            </div>
            <div class="controls">
                <label><input type="checkbox" id="iw_showV" checked /> Potential</label>
                <label><input type="checkbox" id="iw_showProb" checked /> |ψ|²</label>
                <label><input type="checkbox" id="iw_showWave" /> ψ (overlay)</label>
                <label><input type="checkbox" id="iw_showE" checked /> Energy lines</label>
                <label><input type="checkbox" id="iw_auto" checked /> Auto update</label>
                <button id="iw_save">Download PNG</button>
            </div>
            <div id="iw_plot" class="plot"></div>
            <div class="small" id="iw_info"></div>
        </div>

        <!-- Finite Square Well -->
        <div class="problem">
            <h2>2. Finite Square Well</h2>
            <div class="equation">V(x) = −V₀ for |x| ≤ a/2; 0 elsewhere</div>
            <div class="info">A finite-depth well supports a finite number of bound states with E &lt; 0. Adjust width and depth.</div>
            <div class="slider-grid">
                <div class="slider-container">
                    <label>Domain L (nm): <span id="fw_L_val">4.0</span></label>
                    <input id="fw_L" type="range" min="2" max="12" step="0.5" value="4" />
                </div>
                <div class="slider-container">
                    <label>Well width a (nm): <span id="fw_a_val">0.6</span></label>
                    <input id="fw_a" type="range" min="0.2" max="4" step="0.1" value="0.6" />
                </div>
                <div class="slider-container">
                    <label>Well depth V₀ (eV): <span id="fw_V0_val">0.50</span></label>
                    <input id="fw_V0" type="range" min="0.05" max="1.5" step="0.05" value="0.50" />
                </div>
                <div class="slider-container">
                    <label>Grid points N: <span id="fw_N_val">220</span></label>
                    <input id="fw_N" type="range" min="100" max="360" step="10" value="220" />
                </div>
                <div class="slider-container">
                    <label>States to show: <span id="fw_K_val">5</span></label>
                    <input id="fw_K" type="range" min="1" max="8" step="1" value="5" />
                </div>
            </div>
            <div class="controls">
                <button id="fw_run">Compute</button>
            </div>
            <div class="controls">
                <label><input type="checkbox" id="fw_showV" checked /> Potential</label>
                <label><input type="checkbox" id="fw_showProb" checked /> |ψ|²</label>
                <label><input type="checkbox" id="fw_showWave" /> ψ (overlay)</label>
                <label><input type="checkbox" id="fw_showE" checked /> Energy lines</label>
                <label><input type="checkbox" id="fw_auto" checked /> Auto update</label>
                <button id="fw_save">Download PNG</button>
            </div>
            <div id="fw_plot" class="plot"></div>
            <div class="small" id="fw_info"></div>
        </div>

        <!-- Rectangular Barrier in a box -->
        <div class="problem">
            <h2>3. Rectangular Barrier (in a box)</h2>
            <div class="equation">V(x) = +V₀ for |x| ≤ b/2; 0 elsewhere (Dirichlet at edges)</div>
            <div class="info">A barrier within a box splits and reshapes eigenstates. Adjust height and width.</div>
            <div class="slider-grid">
                <div class="slider-container">
                    <label>Domain L (nm): <span id="br_L_val">4.0</span></label>
                    <input id="br_L" type="range" min="2" max="12" step="0.5" value="4" />
                </div>
                <div class="slider-container">
                    <label>Barrier width b (nm): <span id="br_b_val">0.5</span></label>
                    <input id="br_b" type="range" min="0.2" max="4" step="0.1" value="0.5" />
                </div>
                <div class="slider-container">
                    <label>Barrier height V₀ (eV): <span id="br_V0_val">0.40</span></label>
                    <input id="br_V0" type="range" min="0.05" max="1.5" step="0.05" value="0.40" />
                </div>
                <div class="slider-container">
                    <label>Grid points N: <span id="br_N_val">220</span></label>
                    <input id="br_N" type="range" min="100" max="360" step="10" value="220" />
                </div>
                <div class="slider-container">
                    <label>States to show: <span id="br_K_val">5</span></label>
                    <input id="br_K" type="range" min="1" max="8" step="1" value="5" />
                </div>
            </div>
            <div class="controls">
                <button id="br_run">Compute</button>
            </div>
            <div class="controls">
                <label><input type="checkbox" id="br_showV" checked /> Potential</label>
                <label><input type="checkbox" id="br_showProb" checked /> |ψ|²</label>
                <label><input type="checkbox" id="br_showWave" /> ψ (overlay)</label>
                <label><input type="checkbox" id="br_showE" checked /> Energy lines</label>
                <label><input type="checkbox" id="br_auto" checked /> Auto update</label>
                <button id="br_save">Download PNG</button>
            </div>
            <div id="br_plot" class="plot"></div>
            <div class="small" id="br_info"></div>
        </div>

        <!-- Harmonic Oscillator -->
        <div class="problem">
            <h2>4. Simple Harmonic Oscillator</h2>
            <div class="equation">V(x) = ½ m ω² x² (Dirichlet at edges of finite domain)</div>
            <div class="info">The SHO has equally spaced energy levels Eₙ = ħω(n + ½). Adjust ω and domain span.</div>
            <div class="slider-grid">
                <div class="slider-container">
                    <label>ω (rad/s): <span id="ho_w_val">2.0e15</span></label>
                    <input id="ho_w" type="range" min="5e14" max="5e15" step="1e14" value="2e15" />
                </div>
                <div class="slider-container">
                    <label>Domain span multiplier (×x₀): <span id="ho_span_val">10</span></label>
                    <input id="ho_span" type="range" min="6" max="20" step="1" value="10" />
                </div>
                <div class="slider-container">
                    <label>Grid points N: <span id="ho_N_val">240</span></label>
                    <input id="ho_N" type="range" min="120" max="360" step="10" value="240" />
                </div>
                <div class="slider-container">
                    <label>States to show: <span id="ho_K_val">5</span></label>
                    <input id="ho_K" type="range" min="1" max="8" step="1" value="5" />
                </div>
            </div>
            <div class="controls">
                <button id="ho_run">Compute</button>
            </div>
            <div class="controls">
                <label><input type="checkbox" id="ho_showV" checked /> Potential</label>
                <label><input type="checkbox" id="ho_showProb" checked /> |ψ|²</label>
                <label><input type="checkbox" id="ho_showWave" /> ψ (overlay)</label>
                <label><input type="checkbox" id="ho_showE" checked /> Energy lines</label>
                <label><input type="checkbox" id="ho_auto" checked /> Auto update</label>
                <button id="ho_save">Download PNG</button>
            </div>
            <div id="ho_plot" class="plot"></div>
            <div class="small" id="ho_info"></div>
        </div>
    </div>

    <script>
    // ================================
    // Constants (SI units)
    // ================================
    const HBAR = 1.054571817e-34; // J*s
    const M_E = 9.1093837015e-31; // kg
    const E_CHARGE = 1.602176634e-19; // C (J/eV conversion)
    const NM = 1e-9;

    // ================================
    // Linear algebra: Jacobi eigen-solver for symmetric matrices
    // Computes all eigenpairs (small N), returns sorted ascending
    // ================================
    function jacobiEigenSymmetric(A, tol = 1e-10, maxSweeps = 80) {
        const n = A.length;
        const V = identity(n);
        const a = cloneMatrix(A); // work on a copy

        function maxOffDiag(a) {
            let p = 0, q = 1, maxVal = Math.abs(a[p][q]);
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const v = Math.abs(a[i][j]);
                    if (v > maxVal) { maxVal = v; p = i; q = j; }
                }
            }
            return {p, q, maxVal};
        }

        for (let sweep = 0; sweep < maxSweeps; sweep++) {
            const {p, q, maxVal} = maxOffDiag(a);
            if (maxVal < tol) break;

            const app = a[p][p], aqq = a[q][q], apq = a[p][q];
            const tau = (aqq - app) / (2 * apq);
            const t = Math.sign(tau) / (Math.abs(tau) + Math.sqrt(1 + tau * tau));
            const c = 1 / Math.sqrt(1 + t * t);
            const s = t * c;

            // Rotate rows/cols p and q of a
            for (let i = 0; i < n; i++) {
                if (i !== p && i !== q) {
                    const aip = a[i][p];
                    const aiq = a[i][q];
                    a[i][p] = c * aip - s * aiq;
                    a[p][i] = a[i][p];
                    a[i][q] = c * aiq + s * aip;
                    a[q][i] = a[i][q];
                }
            }
            // Update diagonals
            a[p][p] = c*c*app - 2*s*c*apq + s*s*aqq;
            a[q][q] = s*s*app + 2*s*c*apq + c*c*aqq;
            a[p][q] = 0; a[q][p] = 0;

            // Update eigenvectors V
            for (let i = 0; i < n; i++) {
                const vip = V[i][p];
                const viq = V[i][q];
                V[i][p] = c * vip - s * viq;
                V[i][q] = s * vip + c * viq;
            }
        }

        const eigvals = new Array(n);
        for (let i = 0; i < n; i++) eigvals[i] = a[i][i];
        const {values, vectors} = sortEigenpairs(eigvals, V);
        return {values, vectors};
    }

    function identity(n) {
        const I = new Array(n);
        for (let i = 0; i < n; i++) { I[i] = new Array(n).fill(0); I[i][i] = 1; }
        return I;
    }
    function cloneMatrix(A) {
        return A.map(row => row.slice());
    }
    function sortEigenpairs(values, V) {
        const idx = values.map((v, i) => [v, i]).sort((a, b) => a[0] - b[0]).map(x => x[1]);
        const sortedVals = idx.map(i => values[i]);
        const sortedVecs = V.map(row => idx.map(j => row[j]));
        return {values: sortedVals, vectors: sortedVecs};
    }

    // ================================
    // Discretization and solver
    // ================================
    function generateGrid(L_nm, N) {
        const L = L_nm * NM; // meters
        const x = new Array(N);
        const dx = L / (N - 1);
        const start = -L / 2;
        for (let i = 0; i < N; i++) x[i] = start + i * dx;
        return {x, dx};
    }

    function buildHamiltonian(x, V, mass) {
        const N = x.length;
        const dx = x[1] - x[0];
        const pref = (HBAR * HBAR) / (2 * mass * dx * dx);
        const H = new Array(N);
        for (let i = 0; i < N; i++) H[i] = new Array(N).fill(0);
        for (let i = 0; i < N; i++) {
            H[i][i] = 2 * pref + V[i];
            if (i > 0) {
                H[i][i-1] = -pref;
                H[i-1][i] = -pref;
            }
        }
        return H;
    }

    function normalizeEigenvectors(x, vecs) {
        const N = x.length;
        const dx = x[1] - x[0];
        const M = vecs[0].length; // columns
        const out = new Array(N);
        for (let i = 0; i < N; i++) out[i] = new Array(M);
        for (let j = 0; j < M; j++) {
            let norm2 = 0;
            for (let i = 0; i < N; i++) norm2 += vecs[i][j] * vecs[i][j] * dx;
            const norm = Math.sqrt(norm2);
            const scale = norm > 0 ? 1 / norm : 1;
            for (let i = 0; i < N; i++) out[i][j] = vecs[i][j] * scale;
        }
        return out;
    }

    function solveEigen(x, V, mass, kWanted) {
        const H = buildHamiltonian(x, V, mass);
        const {values, vectors} = jacobiEigenSymmetric(H, 1e-12, 60);
        // vectors are columns in our representation: stored row-major; we returned V as [row][col]
        // Already sorted ascending
        const N = x.length;
        const M = vectors[0].length;
        const K = Math.min(kWanted, M);
        const psiCols = new Array(N);
        for (let i = 0; i < N; i++) psiCols[i] = vectors[i].slice(0, K);
        const psi = normalizeEigenvectors(x, psiCols);
        const energies = values.slice(0, K);
        return {energies, psi};
    }

    // Options reader and helpers
    function readOptions(prefix) {
        const get = id => document.getElementById(`${prefix}_${id}`);
        return {
            showPotential: get('showV') ? get('showV').checked : true,
            showProb: get('showProb') ? get('showProb').checked : true,
            showWave: get('showWave') ? get('showWave').checked : false,
            showEnergy: get('showE') ? get('showE').checked : true,
        };
    }
    function isAuto(prefix) {
        const el = document.getElementById(`${prefix}_auto`);
        return el ? el.checked : false;
    }
    function saveCanvas(canvasId, filename) {
        const canvas = document.getElementById(canvasId);
        const link = document.createElement('a');
        link.download = filename;
        link.href = canvas.toDataURL('image/png');
        link.click();
    }

    // ================================
    // Potentials
    // ================================
    function potentialZero(x) {
        return x.map(() => 0);
    }
    function potentialFiniteWell(x, a_nm, V0_eV) {
        const a = a_nm * NM; // meters
        const V0 = -V0_eV * E_CHARGE; // negative inside well
        const V = new Array(x.length);
        for (let i = 0; i < x.length; i++) {
            V[i] = (Math.abs(x[i]) <= a / 2) ? V0 : 0;
        }
        return V;
    }
    function potentialBarrier(x, b_nm, V0_eV) {
        const b = b_nm * NM; // meters
        const V0 = V0_eV * E_CHARGE; // positive barrier
        const V = new Array(x.length);
        for (let i = 0; i < x.length; i++) {
            V[i] = (Math.abs(x[i]) <= b / 2) ? V0 : 0;
        }
        return V;
    }
    function potentialSHO(x, mass, omega) {
        const V = new Array(x.length);
        for (let i = 0; i < x.length; i++) V[i] = 0.5 * mass * omega * omega * x[i] * x[i];
        return V;
    }

    // ================================
    // Rendering utilities
    // ================================
    function drawPotentialAndDensities(containerId, x, V, energies, psi, title, options = {}) {
        // Render with SVG for crisper plots
        const wrap = document.getElementById(containerId);
        wrap.innerHTML = '';
        const W = wrap.clientWidth || 1000;
        const H = wrap.clientHeight || 560;

        const svgns = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgns, 'svg');
        svg.setAttribute('width', W);
        svg.setAttribute('height', H);
        svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
        svg.style.background = '#ffffff';
        wrap.appendChild(svg);

        const showPotential = options.showPotential !== false;
        const showProb = options.showProb !== false;
        const showWave = options.showWave === true;
        const showEnergy = options.showEnergy !== false;

        // Helpers
        function line(x1, y1, x2, y2, color, width, dash) {
            const l = document.createElementNS(svgns, 'line');
            l.setAttribute('x1', x1); l.setAttribute('y1', y1);
            l.setAttribute('x2', x2); l.setAttribute('y2', y2);
            l.setAttribute('stroke', color);
            if (width) l.setAttribute('stroke-width', width);
            if (dash) l.setAttribute('stroke-dasharray', dash);
            svg.appendChild(l);
        }
        function path(d, stroke, width, fill, opacity, dash) {
            const p = document.createElementNS(svgns, 'path');
            p.setAttribute('d', d);
            p.setAttribute('fill', fill || 'none');
            p.setAttribute('stroke', stroke || 'none');
            if (width) p.setAttribute('stroke-width', width);
            if (opacity != null) p.setAttribute('opacity', opacity);
            if (dash) p.setAttribute('stroke-dasharray', dash);
            svg.appendChild(p);
        }
        function text(x, y, str, size = 12, color = '#111827', anchor = 'start') {
            const t = document.createElementNS(svgns, 'text');
            t.setAttribute('x', x); t.setAttribute('y', y);
            t.setAttribute('fill', color);
            t.setAttribute('font-size', size);
            t.setAttribute('font-family', 'Arial, sans-serif');
            t.setAttribute('text-anchor', anchor);
            t.textContent = str;
            svg.appendChild(t);
        }

        // Convert units
        const x_nm = x.map(xi => xi / NM);
        const V_eV = V.map(v => v / E_CHARGE);

        // Determine y scaling (pad top/bottom for clarity)
        const Vmin = Math.min(...V_eV);
        const Vmax = Math.max(...V_eV);
        let ymin = Math.min(Vmin, 0);
        let ymax = Math.max(Vmax, (energies[energies.length-1] / E_CHARGE));
        const pad = (ymax - ymin) * 0.15 || 1;
        ymin -= pad; ymax += pad;
        if (!isFinite(ymin)) ymin = 0; if (!isFinite(ymax) || ymax <= ymin) ymax = ymin + 1;

        // Axes helpers
        function xToPx(xv) { const x0 = x_nm[0], x1 = x_nm[x_nm.length-1]; return (xv - x0) * (W - 80) / (x1 - x0) + 60; }
        function yToPx(ev) { return H - 40 - (ev - ymin) * (H - 80) / (ymax - ymin); }

        // Draw axes
        line(50, 20, 50, H - 30, '#9ca3af', 1);
        line(50, H - 30, W - 20, H - 30, '#9ca3af', 1);
        text(W - 60, H - 10, 'x (nm)');
        // y label (approx by rotated text near top-left)
        text(20, 30, 'Energy / Potential (eV)');

        // Draw potential
        if (showPotential) {
            let d = '';
            for (let i = 0; i < x_nm.length; i++) {
                const px = xToPx(x_nm[i]);
                const py = yToPx(V_eV[i]);
                d += (i === 0 ? `M ${px} ${py}` : ` L ${px} ${py}`);
            }
            path(d, '#111827', 2);
        }

        // Draw probability densities of first few states
        const colors = ['#1d4ed8', '#059669', '#dc2626', '#9333ea', '#f59e0b', '#0ea5e9'];
        // Compute scale for densities
        let maxProb = 0;
        for (let j = 0; j < psi[0].length; j++) {
            for (let i = 0; i < x.length; i++) maxProb = Math.max(maxProb, psi[i][j]*psi[i][j]);
        }
        const probScale = (ymax - ymin) * 0.12 / (maxProb > 0 ? maxProb : 1); // 12% of vertical range
        let maxAmp = 0;
        for (let j = 0; j < psi[0].length; j++) {
            for (let i = 0; i < x.length; i++) maxAmp = Math.max(maxAmp, Math.abs(psi[i][j]));
        }
        const waveScale = (ymax - ymin) * 0.06 / (maxAmp > 0 ? maxAmp : 1); // 6%

        for (let j = 0; j < psi[0].length; j++) {
            const E_eV = energies[j] / E_CHARGE;

            if (showProb) {
                const c = colors[j % colors.length];
                let d = '';
                for (let i = 0; i < x.length; i++) {
                    const prob = psi[i][j] * psi[i][j] * probScale;
                    const px = xToPx(x_nm[i]);
                    const py = yToPx(E_eV + prob);
                    d += (i === 0 ? `M ${px} ${py}` : ` L ${px} ${py}`);
                }
                // stroke curve
                path(d, c, 2);
                // fill under curve
                d += ` L ${xToPx(x_nm[x_nm.length-1])} ${yToPx(E_eV)} L ${xToPx(x_nm[0])} ${yToPx(E_eV)} Z`;
                path(d, 'none', 0, c, 0.10);
            }

            if (showWave) {
                const c = colors[j % colors.length];
                let d = '';
                for (let i = 0; i < x.length; i++) {
                    const px = xToPx(x_nm[i]);
                    const py = yToPx(E_eV + psi[i][j] * waveScale);
                    d += (i === 0 ? `M ${px} ${py}` : ` L ${px} ${py}`);
                }
                path(d, c, 1.6);
            }

            if (showEnergy) {
                const y = yToPx(E_eV);
                line(xToPx(x_nm[0]), y, xToPx(x_nm[x_nm.length-1]), y, colors[j % colors.length], 1, '5,3');
            }
        }

        // Title
        text(60, 18, title, 14, '#111827');
    }

    // ================================
    // UI Handlers: Infinite Well
    // ================================
    function runInfiniteWell() {
        const L = parseFloat(document.getElementById('iw_L').value);
        const N = parseInt(document.getElementById('iw_N').value);
        const K = parseInt(document.getElementById('iw_K').value);
        document.getElementById('iw_L_val').textContent = L.toFixed(1);
        document.getElementById('iw_N_val').textContent = N.toString();
        document.getElementById('iw_K_val').textContent = K.toString();

        const {x} = generateGrid(L, N);
        const V = potentialZero(x);
        const {energies, psi} = solveEigen(x, V, M_E, K);
        const opts = readOptions('iw');
        drawPotentialAndDensities('iw_canvas', x, V, energies, psi, `Infinite Well (L = ${L.toFixed(2)} nm)`, opts);

        // Display first few energies in eV
        const eList = energies.map((E, i) => `n=${i+1}: ${(E/E_CHARGE).toFixed(6)} eV`).join(' | ');
        document.getElementById('iw_info').textContent = `Energies: ${eList}`;
    }

    // ================================
    // UI Handlers: Finite Well
    // ================================
    function runFiniteWell() {
        const L = parseFloat(document.getElementById('fw_L').value);
        const a = parseFloat(document.getElementById('fw_a').value);
        const V0 = parseFloat(document.getElementById('fw_V0').value);
        const N = parseInt(document.getElementById('fw_N').value);
        const K = parseInt(document.getElementById('fw_K').value);
        document.getElementById('fw_L_val').textContent = L.toFixed(1);
        document.getElementById('fw_a_val').textContent = a.toFixed(1);
        document.getElementById('fw_V0_val').textContent = V0.toFixed(2);
        document.getElementById('fw_N_val').textContent = N.toString();
        document.getElementById('fw_K_val').textContent = K.toString();

        const {x} = generateGrid(L, N);
        const V = potentialFiniteWell(x, a, V0);
        const {energies, psi} = solveEigen(x, V, M_E, K);
        const opts = readOptions('fw');
        drawPotentialAndDensities('fw_canvas', x, V, energies, psi, `Finite Well (a=${a.toFixed(2)} nm, V₀=${V0.toFixed(2)} eV)`, opts);

        // Bound states E < 0
        const eList = energies.map((E, i) => ({i, E_eV: E/E_CHARGE}));
        const bound = eList.filter(e => e.E_eV < 0);
        const txt = eList.map(e => `n=${e.i}: ${e.E_eV.toFixed(6)} eV`).join(' | ');
        const prefix = `Energies: ${txt}`;
        const note = `; Bound states: ${bound.length}`;
        document.getElementById('fw_info').textContent = prefix + note;
    }

    // ================================
    // UI Handlers: Barrier in Box
    // ================================
    function runBarrier() {
        const L = parseFloat(document.getElementById('br_L').value);
        const b = parseFloat(document.getElementById('br_b').value);
        const V0 = parseFloat(document.getElementById('br_V0').value);
        const N = parseInt(document.getElementById('br_N').value);
        const K = parseInt(document.getElementById('br_K').value);
        document.getElementById('br_L_val').textContent = L.toFixed(1);
        document.getElementById('br_b_val').textContent = b.toFixed(1);
        document.getElementById('br_V0_val').textContent = V0.toFixed(2);
        document.getElementById('br_N_val').textContent = N.toString();
        document.getElementById('br_K_val').textContent = K.toString();

        const {x} = generateGrid(L, N);
        const V = potentialBarrier(x, b, V0);
        const {energies, psi} = solveEigen(x, V, M_E, K);
        const opts = readOptions('br');
        drawPotentialAndDensities('br_canvas', x, V, energies, psi, `Barrier (b=${b.toFixed(2)} nm, V₀=${V0.toFixed(2)} eV)`, opts);

        const txt = energies.map((E, i) => `n=${i}: ${(E/E_CHARGE).toFixed(6)} eV`).join(' | ');
        document.getElementById('br_info').textContent = `Energies: ${txt}`;
    }

    // ================================
    // UI Handlers: SHO
    // ================================
    function runSHO() {
        const omega = parseFloat(document.getElementById('ho_w').value);
        const spanMul = parseInt(document.getElementById('ho_span').value);
        const N = parseInt(document.getElementById('ho_N').value);
        const K = parseInt(document.getElementById('ho_K').value);
        document.getElementById('ho_w_val').textContent = omega.toExponential(2);
        document.getElementById('ho_span_val').textContent = spanMul.toString();
        document.getElementById('ho_N_val').textContent = N.toString();
        document.getElementById('ho_K_val').textContent = K.toString();

        const x0 = Math.sqrt(HBAR / (M_E * omega));
        const span = spanMul * x0; // cover ±span
        const x = new Array(N);
        const dx = (2*span) / (N - 1);
        for (let i = 0; i < N; i++) x[i] = -span + i * dx;

        const V = potentialSHO(x, M_E, omega);
        const {energies, psi} = solveEigen(x, V, M_E, K);
        const opts = readOptions('ho');
        drawPotentialAndDensities('ho_canvas', x, V, energies, psi, `SHO (ω=${omega.toExponential(2)} rad/s, span=${spanMul}×x₀)`, opts);

        // Analytical E_n = ħω(n + 1/2)
        const ana = Array.from({length: K}, (_, n) => HBAR*omega*(n+0.5)/E_CHARGE);
        const num = energies.map(E => E/E_CHARGE);
        let txt = '';
        for (let i = 0; i < K; i++) txt += `n=${i}: num=${num[i].toFixed(6)} eV, ana=${ana[i].toFixed(6)} eV | `;
        document.getElementById('ho_info').textContent = txt;
    }

    // Bind
    document.getElementById('iw_run').onclick = runInfiniteWell;
    document.getElementById('fw_run').onclick = runFiniteWell;
    document.getElementById('br_run').onclick = runBarrier;
    document.getElementById('ho_run').onclick = runSHO;

    // Auto-update bindings for sliders and toggles
    const bindAuto = (prefix, ids, handler, canvasId, saveBtnId, filename) => {
        ids.forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;
            const evt = el.tagName === 'INPUT' && el.type === 'range' ? 'input' : 'change';
            el.addEventListener(evt, () => { if (isAuto(prefix)) handler(); });
        });
        const saveBtn = document.getElementById(saveBtnId);
        if (saveBtn) saveBtn.onclick = () => {
            // Export current SVG as PNG
            const wrap = document.getElementById(canvasId.replace('_canvas','_plot')) || document.getElementById(canvasId);
            const svg = wrap.querySelector('svg');
            if (!svg) return;
            const serializer = new XMLSerializer();
            const svgStr = serializer.serializeToString(svg);
            const img = new Image();
            const blob = new Blob([svgStr], {type: 'image/svg+xml;charset=utf-8'});
            const url = URL.createObjectURL(blob);
            img.onload = function() {
                const canvas = document.createElement('canvas');
                canvas.width = svg.viewBox.baseVal.width || svg.width.baseVal.value;
                canvas.height = svg.viewBox.baseVal.height || svg.height.baseVal.value;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);
                const a = document.createElement('a');
                a.download = filename;
                a.href = canvas.toDataURL('image/png');
                a.click();
            };
            img.src = url;
        };
    };

    bindAuto('iw', ['iw_L','iw_N','iw_K','iw_showV','iw_showProb','iw_showWave','iw_showE','iw_auto'], runInfiniteWell, 'iw_canvas', 'iw_save', 'infinite_well.png');
    bindAuto('fw', ['fw_L','fw_a','fw_V0','fw_N','fw_K','fw_showV','fw_showProb','fw_showWave','fw_showE','fw_auto'], runFiniteWell, 'fw_canvas', 'fw_save', 'finite_well.png');
    bindAuto('br', ['br_L','br_b','br_V0','br_N','br_K','br_showV','br_showProb','br_showWave','br_showE','br_auto'], runBarrier, 'br_canvas', 'br_save', 'barrier.png');
    bindAuto('ho', ['ho_w','ho_span','ho_N','ho_K','ho_showV','ho_showProb','ho_showWave','ho_showE','ho_auto'], runSHO, 'ho_canvas', 'ho_save', 'sho.png');

    // Initial renders
    window.onload = function() {
        runInfiniteWell();
        runFiniteWell();
        runBarrier();
        runSHO();
    };
    </script>
 </body>
 </html>


